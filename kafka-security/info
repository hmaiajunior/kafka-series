Ao trabalhar com segurança no kafka falamos de autenticação, autorização e criptografia.

Criptografia:

Embora geralmente se use o termo SSL, o protocolo mais atual a ser usado é o TLS (Transport Layer Security), que é o sucessor do SSL e tem como objetivo encriptar a conexão entre dois endpoints para comunicação segura.

Ao utilizar uma comunicação criptografa entre o client o broker kafka, o client confia no certificado do broker e dessa forma eles podem trocar informações com segurança. 

É possível também utilizar o SSL/TLS para um processo de autenticação onde o broker irá autenticar o client através de um processo chamado de mTLS.

Hands-On:

Criando uma CA:

Vamos configurar o nosso cluster para começar a aceitar requisições TLS e para isso iniciaremos criando uma CA com o comando abaixo:

==> openssl req -new -newkey rsa:4096 -days 365 -x509 -subj "/CN=Kafka-Security-CA" -keyout ca-key -out ca-cert -nodes

O comando acima irá gerar 2 arquivos, o arquivo "ca-key" (chave-privada) que será usado para assinar certificados de clientes ou brokers e o "ca-cert" (certificado público) que é o certificado que deve ser distribuído aos brokers e clientes para que confiem nas assinaturas feitas pela CA.

O arquivo ca-cert funciona como a truststore, permitindo que o broker ou cliente Kafka valide os certificados apresentados durante a conexão SSL. Se esses certificados forem assinados pela mesma Autoridade Certificadora (CA) que emitiu o ca-cert, eles serão reconhecidos como confiáveis e a conexão será estabelecida com sucesso.

Agora vamos executar o comando para criar a keystore do nosso primeiro broker:

Antes de executar, exporte a variável SRVPASS: export SRVPASS=serversecret

==> keytool -genkey -keystore kafka.external.keystore.jks -validity 365 -storepass $SRVPASS -keypass $SRVPASS -dname "CN=localhost" -ext SAN=DNS:localhost,IP:127.0.0.1 -storetype pkcs12

A keystore gerada pode ser verificada com o comando abaixo:

keytool -list -v -keystore kafka.server.keystore.jks

Agora o comando abaixo deve ser executado para criar uma requisição de assinatura de certificado, CSR:

==> keytool -keystore kafka.server.keystore.jks -certreq -file cert-file -storepass $SRVPASS -keypass $SRVPASS

Com o comando acima executado o arquivo cert-file foi gerado. Esse arquivo é o CSR.

Agora vamos assinar o certificado a partir da requisição de assinatura gerada no comando anterior:

==> openssl x509 -req -CA ca-cert -CAkey ca-key -in cert-file -out cert-signed -days 365 -CAcreateserial -passin pass:$SRVPASS

O arquivo cert-signed, que é o certificado assinado, foi gerado. Utilize o comando abaixo para verificar o certificado:

keytool -printcert -v -file cert-signed

Agora vamos executar o comando que irá importar o certificado assinado na truststore, que é essencial para que o kafka confie em certificados assinados por essa CA:

==> keytool -keystore kafka.server.truststore.jks -alias CARoot -import -file ca-cert -storepass $SRVPASS -keypass $SRVPASS -noprompt

Lembrando que o ca-cert passado pelo comando é o certificado público gerado pela CA no primeiro comando que foi executado para gerar a CA.

Agora vamos realizar o import do certificado público da CA e do certificado assinado pela CA que será utilizado pelo broker. O import será feito na keystore e deve ser feito exatamente na ordem abaixo:

==> keytool -keystore kafka.server.keystore.jks -alias CARoot -import -file ca-cert -storepass $SRVPASS -keypass $SRVPASS -noprompt
==> keytool -keystore kafka.server.keystore.jks -import -file cert-signed -storepass $SRVPASS -keypass $SRVPASS -noprompt

OBSERVAÇÃO IMPORTANTE:

Ao gerar a keystore com o comando acima eu não consegui validar a autenticação com o broker, pois estava tomando erro de ssl handshake failed. Isso estava acontecendo porque a chave privada do certificado do broker, o que não pode ser realizado com o keytool. 

Para corrigir essa questão utilizei o openssl no comando abaixo:

openssl pkcs12 -export -in broker-cert.pem -inkey broker-key.pem -out kafka.server.keystore.p12 -name kafka-broker -CAfile ca-cert -caname Kafka-Security-CA -passout pass:$SRVPASS

E depois executei o comando que importa um keystore no formato PKCS#12 (.p12) para o formato JKS (.jks), que é o mais comum em ambientes Java/Kafka:

keytool -importkeystore -destkeystore kafka.server.keystore.jks -srckeystore kafka.server.keystore.p12 -srcstoretype PKCS12 -alias kafka-broker -deststorepass $SRVPASS -destkeypass $SRVPASS -srcstorepass $SRVPASS



Execute o comando abaixo para testar a conexão via SSL com o broker:

openssl s_client -connect <<your-public-DNS>>:9093

openssl s_client   -connect localhost:9091   -cert client-cert.pem   -key client-key.pem   -CAfile ca-cert   -showcerts


Procedimento para gerar a chave para o cliente:

==> openssl genrsa -out client-key.pem 2048

==> openssl req -new -key client-key.pem -out client-req.csr \
  -subj "/CN=kafka-client"

==> openssl x509 -req -in client-req.csr -CA ca-cert.pem -CAkey ca-key.pem \
  -CAcreateserial -out client-cert.pem -days 365 -sha256


Agora é necessário realizar a criação da keystore e truststore para o cliente. 

Segue comando para criação da truststore onde nela já foi inserida o certificado público da nossa CA o que significa que todos os certificados assinados por essa CA serão reconhecidos como válidos para esse cliente:

keytool -keystore kafka.client.truststore.jks -alias CARoot -import -file ca-cert  -storepass $CLIPASS -keypass $CLIPASS -noprompt

Uma vez criada a CA será necessário apenas configurar um arquivo de configuração com as propriedades abaixo:

security.protocol=SSL
ssl.truststore.location=/home/henrique/Documentos/treinamentos/kafka-series/kafka-security/app-cert-ssl/kafka.client.truststore.jks
ssl.truststore.password=clientpass

IMPORTATE: Se o broker exigir autenticação mTLS será necessário que o app também apresente um certificado, apenas o certificado público da CA não será suficiente na truststore.

No nosso caso está sendo exigida a autenticação mútua que citei acima, desse modo iremos criar um certificado para a nossa aplicação python conseguir produzir mensagens autenticando via ssl/tls no broker. Segue os comandos necessários para a criação do certificado:

1 - Gerar chave privada do cliente:

openssl genrsa -out client-key.pem 2048

2 - Gerar o CSR:

openssl req -new -key client-key.pem -out client.csr -subj "/CN=python-producer"

3 - Assinar o certificado com a CA:

openssl x509 -req -in client.csr -CA ca-cert -CAkey ca-key -CAcreateserial -out client-cert.pem -days 365 -sha256

OBS: A qualquer momento você pode verificar o certificado gerado com o comando abaixo:

==> openssl x509 -in client-cert.pem -text -noout

ou apenas o comando abaixo para verificar exibir o CN do certificado que é o que importa na hora de configurar as ACLs:

==> openssl x509 -in client-cert.pem -noout -subject

Podemos listar de forma simultânea o CN do principal que será usado no certificado e o CN do issuer que assinou o certificado:

==> openssl x509 -in client-cert.pem -noout -subject -issuer

Já em nosso python producer a configuração abaixo será necessária para conseguir conectar no cluster:

# Configurações de conexão com o Kafka via SSL/TLS com mTLS
producer_config = {
    'bootstrap.servers': 'localhost:9091,localhost:9092,localhost:9093',
    'security.protocol': 'SSL',
    'ssl.ca.location': '/home/henrique/Documentos/treinamentos/kafka-series/kafka-security/app-cert-ssl/ca-cert',
    'ssl.certificate.location': '/home/henrique/Documentos/treinamentos/kafka-series/kafka-security/app-cert-ssl/client-cert.pem',
    'ssl.key.location': '/home/henrique/Documentos/treinamentos/kafka-series/kafka-security/app-cert-ssl/client-key.pem',
}

OBS:. Um ponto fundamental é que quando adicionamos um certificado para o cliente ele passa também a ser autenticado no broker (mTLS) e com isso passa a ter uma identidade. A partir daí podemos começar a fazer o uso de ACLs para autorizar determinadas ações em nosso cluster.

A configuração no broker que vai exigir a autenticação SSL do client é a seguinte:

SSL_CLIENT_AUTH: required

# ACLs

Quando trabalhamos com ACLs podemos defini-las no seguinte formato:

Principal {P} - Allowed | Denied
Operation {O} - Operation
Host      {H} - Host
Resource  {R} - Resource
Resource Pattern {RP} - Resource Pattern

Por padrão, se nenhum padrão de recurso (RP) corresponder a um recurso (R), então R não terá ACLs associadas e apenas o super usuário do kafka terá permissão em cima de R. Esse padrão pode ser alterado em server.properties:

allow.everyone.if.no.acl.found=true

Outro ponto importante é que  aqui não existe nada relacionado a grupo. As permissões são dadas diretamente para um client / user.

As ACLs são armazenadas no zookeeeper.


